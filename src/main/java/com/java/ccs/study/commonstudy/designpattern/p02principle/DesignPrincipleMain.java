package com.java.ccs.study.commonstudy.designpattern.p02principle;

/**
 * @Author: Cao.cs
 * @Date: Created in 16:55 2022/5/2
 */
public class DesignPrincipleMain {

    /**
     * 设计模式的七大原则
     * (1)单一职责原则
     * 一个类只负责一项职责。
     * <p>
     * (2)接口隔离原则
     * 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
     * -> 拆分成多个接口，不同的类分别实现其接口。
     * <p>
     * (3)依赖倒置原则
     * 1.高层模块不应该依赖底层模块，两者都应该依赖其抽象。
     * 2.抽象不应该依赖细节，细节应该依赖抽象
     * 3.依赖倒置的中心思想是面向接口编程 -> 依赖抽象的东西
     * 4.设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。
     * 在java中，抽象指的是接口或抽象类，细节就是具体的实现类。
     * 5.使用接口或者抽象类的目的是制定好规范，而不设计任何具体的操作，把展现细节的任务交给他们的实现类去完成。
     * 注1：
     * 依赖关系传递的三种方式：接口传递，构造方法传递，setter方法传递。
     * 注2：
     * 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。
     * 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和时间对象间，就存在一个缓冲成，利于程序扩展和优化。
     * 继承时遵循里式替换原则。
     * <p>
     * (4)里氏替换原则
     * 如果子类对已经实现的父类的方法任意修改，就对整个继承体系造成破坏。
     * 如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到左右的子类，并且父类修改后，所有涉及到的子类的功能都可能产生故障。
     * -> 如何正确的使用继承？ -> 里氏替换原则
     * 所有引用基类的地方必须能透明的使用其子类的对象。
     * 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。 -> 改成同时继承自更基础的基类
     * 里氏替换原则告诉我们：继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题。
     * <p>
     * (5)开闭原则
     * 对扩展开放，对修改关闭。
     * -> 用抽象构建框架，用实现扩展细节。
     * <p>
     * (6)迪米特法则
     * 一个对象应该对其他对象保持最少的了解。 -> 最少知道原则
     * 对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外暴露任何信息。
     * 直接朋友：成员变量，方法参数，方法返回值中的类。 而出现在局部变量中的类不是直接的朋友。
     * 陌生的类最好不要以局部变量的形式出现在类的内部。
     * <p>
     * (7)合成复用原则
     * 尽量使用组合/聚合的方式，而不是使用继承。
     * <p>
     * 目标： -> 高内聚,低耦合
     * 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；
     * 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。
     * <p>
     * <p>
     * 设计模式类型：
     * (1)创建型模式
     * 单例模式、简单工厂模式、抽象工厂模式、原型模式、建造者模式
     * (2)结构型模式
     * 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
     * (3)行为型模式
     * 模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、
     * 中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式。
     */
    public static void main(String[] args) {

    }

}
